{
  "rules": {
    "apikeys": {
      "$apikeyId": {
        ".read": "auth != null",
        ".write": "auth != null"
      }
    },


     "messages": {
      // Allow listing of rooms
      ".read": "auth !== null",
      
      "$roomId": {
        // Allow read/write if authenticated
        ".read": "auth !== null",
        ".write": "auth !== null",
        
        "$messageId": {
          // Basic validation for new messages
          ".validate": "newData.hasChildren(['message', 'senderId', 'timestamp'])",
          
          "senderId": {
            ".validate": "newData.isString() && newData.val() === auth.uid"
          },
          
          "message": {
            ".validate": "newData.isString()"
          },
          
          "messageOG": {
            ".validate": "newData.isString()"
          },
          
          "timestamp": {
            ".validate": "newData.isNumber()"
          }
        }
      }
    },

    // Group chat rules
    "groups": {
      // Allow authenticated users to read group list
      ".read": "auth !== null",
      
      "$groupId": {
        // Allow read access if user is a member of the group
        ".read": "auth !== null && (root.child('groups').child($groupId).child('members').child(auth.uid).exists())",
        
        // Allow write if creating a new group (data doesn't exist yet) or if the user is an admin
        ".write": "auth !== null && (!data.exists() || root.child('groups').child($groupId).child('members').child(auth.uid).val() === true)",
        
        // Validate group structure
        ".validate": "newData.hasChildren(['groupId', 'name', 'createdBy', 'createdAt', 'members'])",
        
        "groupId": {
          ".validate": "newData.isString() && newData.val() === $groupId"
        },
        
        "name": {
          ".validate": "newData.isString()"
        },
        
        "description": {
          ".validate": "newData.isString()"
        },
        
        "createdBy": {
          ".validate": "newData.isString() && (newData.val() === auth.uid || data.val() === newData.val())"
        },
        
        "createdAt": {
          ".validate": "newData.isNumber()"
        },
        
        "members": {
          "$userId": {
            // Members are stored as userId: boolean pairs (true means admin)
            ".validate": "newData.isBoolean()",
            // Only admins can modify member list or current user can remove themselves
            ".write": "auth !== null && (root.child('groups').child($groupId).child('members').child(auth.uid).val() === true || $userId === auth.uid)"
          }
        }
      }
    },
    
    "group_messages": {
      // Allow authenticated users to read all group messages
      ".read": "auth !== null",
      // Allow authenticated users to write to group messages
      ".write": "auth !== null",
      
      "$groupId": {
        // Add index on timestamp field for message ordering and context retrieval
        ".indexOn": "timestamp",
        // More specific rules for group messages can be added here if needed
        // But for now, we'll use a simpler approach to get it working
        ".read": "auth !== null",
        ".write": "auth !== null",
        
        "$messageId": {
          // Basic validation for group messages
          ".validate": "newData.hasChildren(['message', 'senderId', 'timestamp'])",
          
          "senderId": {
            ".validate": "newData.isString() && newData.val() === auth.uid"
          },
          
          "senderName": {
            ".validate": "newData.isString()"
          },
          
          "senderProfileUrl": {
            ".validate": "newData.isString()"
          },
          
          "message": {
            ".validate": "newData.isString()"
          },
          
          "messageOG": {
            ".validate": "newData.isString()"
          },
          
          "timestamp": {
            ".validate": "newData.isNumber()"
          }
        }
      }
    },

    "connect_chats": {
      // Allow authenticated users to read/write connect chat messages
      ".read": "auth !== null",
      ".write": "auth !== null",

      "$sessionId": {
        // Add index on timestamp field for message ordering and context retrieval
        ".indexOn": "timestamp",

        "$messageId": {
          // Basic validation for connect chat messages
          ".validate": "newData.hasChildren(['message', 'senderId', 'timestamp'])",

          "senderId": {
            ".validate": "newData.isString() && newData.val() === auth.uid"
          },

          "message": {
            ".validate": "newData.isString()"
          },

          "voiceText": {
            ".validate": "newData.isString()"
          },

          "timestamp": {
            ".validate": "newData.isNumber()"
          },

          "translationState": {
            ".validate": "!newData.exists() || newData.isString() || newData.val() === null"
          },

          "translationMode": {
            ".validate": "!newData.exists() || newData.isString()"
          },

          "isVoiceMessage": {
            ".validate": "!newData.exists() || newData.isBoolean()"
          },

          "senderLanguage": {
            ".validate": "!newData.exists() || newData.isString()"
          }
        }
      }
    },

    "connection_requests": {
      // Allow authenticated users to read/write connection requests
      ".read": "auth !== null",
      ".write": "auth !== null",

      "$requestId": {
        // Add index on timestamp for request ordering
        ".indexOn": "timestamp",

        ".validate": "newData.hasChildren(['requestId', 'fromUserId', 'toUserId', 'status', 'timestamp'])",

        "requestId": {
          ".validate": "newData.isString() && newData.val() === $requestId"
        },

        "fromUserId": {
          ".validate": "newData.isString() && newData.val() === auth.uid"
        },

        "toUserId": {
          ".validate": "newData.isString()"
        },

        "status": {
          ".validate": "newData.isString() && (newData.val() === 'PENDING' || newData.val() === 'ACCEPTED' || newData.val() === 'REJECTED' || newData.val() === 'TIMEOUT' || newData.val() === 'EXPIRED' || newData.val() === 'CANCELLED')"
        },

        "timestamp": {
          ".validate": "newData.isNumber()"
        },

        "expiresAt": {
          ".validate": "newData.isNumber()"
        }
      }
    },

    "voice_messages": {
      // Allow authenticated users to read/write voice messages
      ".read": "auth !== null",
      ".write": "auth !== null",

      "$roomId": {
        // Add index on timestamp for message ordering
        ".indexOn": "timestamp",

        "$messageId": {
          ".validate": "newData.hasChildren(['messageId', 'voiceText', 'timestamp', 'senderId'])",

          "messageId": {
            ".validate": "newData.isString() && newData.val() === $messageId"
          },

          "voiceText": {
            ".validate": "newData.isString()"
          },

          "translatedText": {
            ".validate": "!newData.exists() || newData.isString() || newData.val() === null"
          },

          "timestamp": {
            ".validate": "newData.isNumber()"
          },

          "senderId": {
            ".validate": "newData.isString() && newData.val() === auth.uid"
          },

          "senderLanguage": {
            ".validate": "!newData.exists() || newData.isString()"
          },

          "translationMode": {
            ".validate": "!newData.exists() || newData.isString()"
          },

          "translationState": {
            ".validate": "!newData.exists() || newData.isString() || newData.val() === null"
          }
        }
      }
    },

    "status": {
      
      ".read": "auth !== null",
      "$uid": {
        ".write": "$uid === auth.uid"
      }
    },

    "users": {
      // Allow authenticated users to read all users
      ".read": "auth !== null",
      
      "$uid": {
        // Only allow users to modify their own data
        ".write": "$uid === auth.uid",
        
        // Validate user data structure
        ".validate": "newData.hasChildren(['userId', 'email'])",
        
        "userId": {
          ".validate": "newData.isString() && newData.val() === $uid"
        },
        
        "email": {
          ".validate": "newData.isString()"
        },
        
        "username": {
          ".validate": "newData.isString()"
        },
        
        "language": {
          ".validate": "!newData.exists() || newData.isString()"
        },
        
        "translator": {
          ".validate": "newData.isString()"
        },
        
        "profileImageUrl": {
          ".validate": "newData.isString()"
        },

        "contactsettings": {
          "$contactUserId": {
            "translateMessages": {
              ".validate": "newData.isBoolean()"
            }
          }
        }
      }
    },

    // Usage statistics for admin dashboard
    "usage_statistics": {
      // Allow read access for authenticated users (admin dashboard needs this)
      ".read": "auth !== null",
      // Allow write access for authenticated users (server-side admin operations)
      ".write": "auth !== null",
      
      "$date": {
        // Validate date format (YYYY-MM-DD)
        ".validate": "newData.hasChildren(['date', 'totalUsers', 'calculatedAt'])",
        
        "date": {
          ".validate": "newData.isString()"
        },
        
        "totalUsers": {
          ".validate": "newData.isNumber()"
        },
        
        "activeUsersLast7Days": {
          ".validate": "newData.isNumber()"
        },
        
        "premiumUsers": {
          ".validate": "newData.isNumber()"
        },
        
        "freeUsers": {
          ".validate": "newData.isNumber()"
        },
        
        "newUsersToday": {
          ".validate": "newData.isNumber()"
        },
        
        "dailyLoginCount": {
          ".validate": "newData.isNumber()"
        },
        
        "languageDistribution": {
          ".validate": "newData.hasChildren()"
        },
        
        "createdAt": {
          ".validate": "newData.isString()"
        },
        
        "calculatedAt": {
          ".validate": "newData.isString()"
        }
      }
    }
  }
}